<!DOCTYPE html>
<html>
<head>
  <title>Verlet Cloth Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #222; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script type="module">
    import { VerletJS, Particle, DistanceConstraint, PinConstraint, Composite, Vec2 } from '../../dist/verlet-engine.es.js';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const sim = new VerletJS(canvas.width, canvas.height);
    sim.gravity = new Vec2(0, 0.2);
    sim.friction = 1.0;

    function createCloth(origin, width, height, segments, stiffness) {
      const cloth = new Composite();
      const xStride = width / segments;
      const yStride = height / segments;

      // Create particles
      for (let y = 0; y < segments; y++) {
        for (let x = 0; x < segments; x++) {
          const px = origin.x + x * xStride - width / 2 + xStride / 2;
          const py = origin.y + y * yStride - height / 2 + yStride / 2;
          cloth.particles.push(new Particle(new Vec2(px, py)));
        }
      }

      // Create constraints
      for (let y = 0; y < segments; y++) {
        for (let x = 0; x < segments; x++) {
          if (x > 0) {
            cloth.constraints.push(new DistanceConstraint(cloth.particles[y * segments + x], cloth.particles[y * segments + x - 1], stiffness));
          }
          if (y > 0) {
            cloth.constraints.push(new DistanceConstraint(cloth.particles[y * segments + x], cloth.particles[(y - 1) * segments + x], stiffness));
          }
        }
      }

      // Pin the top row
      for (let x = 0; x < segments; x+=5) {
        cloth.constraints.push(new PinConstraint(cloth.particles[x], cloth.particles[x].pos));
      }

      return cloth;
    }

    // --- Cloth Composite ---
    const segments = 25;
    const cloth = createCloth(new Vec2(canvas.width / 2, canvas.height / 3), 500, 300, segments, 0.9);
    sim.composites.push(cloth);

    // --- Mouse Interaction ---
    let draggedParticle = null;
    canvas.addEventListener('mousedown', (e) => {
      const mousePos = new Vec2(e.clientX, e.clientY);
      // Find the nearest particle in the cloth composite
      let nearest = null;
      let min_dist_sq = Infinity;
      cloth.particles.forEach(p => {
        const dist_sq = p.pos.dist2(mousePos);
        if (dist_sq < min_dist_sq) {
          nearest = p;
          min_dist_sq = dist_sq;
        }
      });

      if (min_dist_sq < 400) { // 20px radius
        draggedParticle = nearest;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (draggedParticle) {
        draggedParticle.pos.x = e.clientX;
        draggedParticle.pos.y = e.clientY;
      }
    });

    canvas.addEventListener('mouseup', () => {
      draggedParticle = null;
    });

    function lerp(a, b, p) {
      return (b - a) * p + a;
    }

    // --- Animation Loop ---
    function animate() {
      sim.frame(16);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Custom cloth rendering
      const stride = cloth.particles[1].pos.x - cloth.particles[0].pos.x;
      for (let y = 1; y < segments; y++) {
        for (let x = 1; x < segments; x++) {
          ctx.beginPath();

          const i1 = (y - 1) * segments + x - 1;
          const i2 = y * segments + x;

          ctx.moveTo(cloth.particles[i1].pos.x, cloth.particles[i1].pos.y);
          ctx.lineTo(cloth.particles[i1 + 1].pos.x, cloth.particles[i1 + 1].pos.y);
          ctx.lineTo(cloth.particles[i2].pos.x, cloth.particles[i2].pos.y);
          ctx.lineTo(cloth.particles[i2 - 1].pos.x, cloth.particles[i2 - 1].pos.y);

          let off = cloth.particles[i2].pos.x - cloth.particles[i1].pos.x;
          off += cloth.particles[i2].pos.y - cloth.particles[i1].pos.y;
          off *= 0.25;

          let stress = Math.abs(off) / stride; // Stress ratio (0 to 1+)
          if (stress > 1) stress = 1;

          let r, g, b;
          if (stress < 1/3) {
              // 1. Red to Yellow
              const p = stress * 3;
              r = 255;
              g = lerp(0, 255, p);
              b = 0;
          } else if (stress < 2/3) {
              // 2. Yellow to Blue
              const p = (stress - 1/3) * 3;
              r = lerp(255, 0, p);
              g = lerp(255, 0, p);
              b = lerp(0, 255, p);
          } else {
              // 3. Blue to Green
              const p = (stress - 2/3) * 3;
              r = 0;
              g = lerp(0, 255, p);
              b = lerp(255, 0, p);
          }

          const alpha = lerp(0.3, 1, stress);
          ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${alpha})`;
          ctx.fill();
        }
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>