<!DOCTYPE html>
<html>
<head>
  <title>Verlet Cloth Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #222; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script type="module">
    import { VerletJS, Vec2, cloth } from '../../dist/verlet-engine.es.js';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const sim = new VerletJS(canvas.width, canvas.height);
    sim.gravity = new Vec2(0, 0.2);
    sim.friction = 1.0;

    // --- Cloth Composite ---
    // Use the new cloth function with separate segmentsX and segmentsY
    const segmentsX = 50;
    const segmentsY = 20;
    const clothComposite = cloth(
      sim, 
      new Vec2(canvas.width / 2, canvas.height / 3), 
      500, 
      300, 
      segmentsX, 
      segmentsY, 
      4, // pinMod
      0.9 // stiffness
    );

    // --- Mouse Interaction ---
    let draggedParticle = null;
    canvas.addEventListener('mousedown', (e) => {
      const mousePos = new Vec2(e.clientX, e.clientY);
      let nearest = null;
      let min_dist_sq = Infinity;
      clothComposite.particles.forEach(p => {
        const dist_sq = p.pos.dist2(mousePos);
        if (dist_sq < min_dist_sq) {
          nearest = p;
          min_dist_sq = dist_sq;
        }
      });

      if (min_dist_sq < 400) { // 20px radius
        draggedParticle = nearest;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (draggedParticle) {
        draggedParticle.pos.x = e.clientX;
        draggedParticle.pos.y = e.clientY;
      }
    });

    canvas.addEventListener('mouseup', () => {
      draggedParticle = null;
    });

    function lerp(a, b, p) {
      return (b - a) * p + a;
    }

    // --- Animation Loop ---
    function animate() {
      sim.frame(16);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Custom cloth rendering
      const stride = clothComposite.particles[1].pos.x - clothComposite.particles[0].pos.x;
      for (let y = 1; y < segmentsY; y++) {
        for (let x = 1; x < segmentsX; x++) {
          ctx.beginPath();

          const i1 = (y - 1) * segmentsX + x - 1;
          const i2 = y * segmentsX + x;

          ctx.moveTo(clothComposite.particles[i1].pos.x, clothComposite.particles[i1].pos.y);
          ctx.lineTo(clothComposite.particles[i1 + 1].pos.x, clothComposite.particles[i1 + 1].pos.y);
          ctx.lineTo(clothComposite.particles[i2].pos.x, clothComposite.particles[i2].pos.y);
          ctx.lineTo(clothComposite.particles[i2 - 1].pos.x, clothComposite.particles[i2 - 1].pos.y);

          let off = clothComposite.particles[i2].pos.x - clothComposite.particles[i1].pos.x;
          off += clothComposite.particles[i2].pos.y - clothComposite.particles[i1].pos.y;
          off *= 0.25;

          let stress = Math.abs(off) / stride;
          if (stress > 1) stress = 1;

          let r, g, b;
          if (stress < 1/3) {
              const p = stress * 3;
              r = 255;
              g = lerp(0, 255, p);
              b = 0;
          } else if (stress < 2/3) {
              const p = (stress - 1/3) * 3;
              r = lerp(255, 0, p);
              g = lerp(255, 0, p);
              b = lerp(0, 255, p);
          } else {
              const p = (stress - 2/3) * 3;
              r = 0;
              g = lerp(0, 255, p);
              b = lerp(255, 0, p);
          }

          const alpha = lerp(0.3, 1, stress);
          ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${alpha})`;
          ctx.fill();
        }
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
