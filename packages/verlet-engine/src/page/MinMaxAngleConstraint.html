<!DOCTYPE html>
<html>
<head>
  <title>MinMaxAngleConstraint Explained</title>
  <style>
    body { margin: 0; font-family: sans-serif; text-align: center; background-color: #f0f0f0; }
    canvas { background-color: #fff; }
  </style>
</head>
<body>
  <h2>MinMaxAngleConstraint Example</h2>
  <p>Drag points A or C. The constraint will keep the angle at B between 45° and 135°.</p>
  <canvas id="canvas"></canvas>
  <script type="module">
    import { VerletJS, Particle, DistanceConstraint, MinMaxAngleConstraint, PinConstraint, Composite, Vec2 } from '../../dist/verlet-engine.es.js';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 600;
    canvas.height = 400;

    // --- Simulation Setup ---
    const sim = new VerletJS(canvas.width, canvas.height);
    sim.gravity = new Vec2(0, 0);

    // --- The 3 Particles ---
    const composite = new Composite();
    
    const pA = new Particle(new Vec2(200, 200));
    const pB = new Particle(new Vec2(300, 200)); // The vertex
    const pC = new Particle(new Vec2(300, 300));

    composite.particles.push(pA, pB, pC);

    // --- The Constraints ---
    composite.constraints.push(new DistanceConstraint(pA, pB, 1));
    composite.constraints.push(new DistanceConstraint(pB, pC, 1));

    // The MinMaxAngleConstraint
    // Keep the angle between 45 degrees (PI/4) and 135 degrees (3*PI/4)
    const minAngle = Math.PI / 4;
    const maxAngle = 3 * Math.PI / 4;
    const minMaxAngle = new MinMaxAngleConstraint(pA, pB, pC, minAngle, maxAngle, 1);
    composite.constraints.push(minMaxAngle);

    sim.composites.push(composite);

    // --- Mouse Interaction ---
    let draggedParticle = null;
    let pinConstraint = null;

    function getNearestParticle(pos, maxRadius = 20) {
      let nearest = null;
      let minDist2 = maxRadius * maxRadius;
      for (const c of sim.composites) {
        for (const p of c.particles) {
          const dist2 = p.pos.dist2(pos);
          if (dist2 < minDist2) {
            minDist2 = dist2;
            nearest = p;
          }
        }
      }
      return nearest;
    }

    canvas.addEventListener('mousedown', (e) => {
      const mousePos = new Vec2(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
      draggedParticle = getNearestParticle(mousePos, 20);
      if (draggedParticle) {
        pinConstraint = new PinConstraint(draggedParticle, mousePos);
        for (const c of sim.composites) {
            if (c.particles.includes(draggedParticle)) {
                c.constraints.push(pinConstraint);
                break;
            }
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (draggedParticle && pinConstraint) {
        pinConstraint.pos.x = e.clientX - canvas.offsetLeft;
        pinConstraint.pos.y = e.clientY - canvas.offsetTop;
      }
    });

    canvas.addEventListener('mouseup', () => {
      if (draggedParticle && pinConstraint) {
        for (const c of sim.composites) {
            const index = c.constraints.indexOf(pinConstraint);
            if (index > -1) {
                c.constraints.splice(index, 1);
                break;
            }
        }
        draggedParticle = null;
        pinConstraint = null;
      }
    });

    // --- Animation Loop ---
    function animate() {
      sim.frame(16);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const c of sim.composites[0].constraints) {
        c.draw(ctx);
      }

      ctx.font = "16px Arial";
      ctx.fillStyle = "black";
      
      ctx.fillText("A", pA.pos.x - 20, pA.pos.y + 5);
      ctx.beginPath();
      ctx.arc(pA.pos.x, pA.pos.y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "#ff6347";
      ctx.fill();

      ctx.fillText("B (Vertex)", pB.pos.x + 10, pB.pos.y - 10);
      ctx.beginPath();
      ctx.arc(pB.pos.x, pB.pos.y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "#4682b4";
      ctx.fill();

      ctx.fillText("C", pC.pos.x + 10, pC.pos.y + 5);
      ctx.beginPath();
      ctx.arc(pC.pos.x, pC.pos.y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "#32cd32";
      ctx.fill();
      
      const currentAngle = pB.pos.angle2(pA.pos, pC.pos) * (180 / Math.PI);
      ctx.fillStyle = (currentAngle < 45 || currentAngle > 135) ? "red" : "black";
      ctx.fillText(`Current Angle: ${currentAngle.toFixed(1)}°`, 20, 30);
      ctx.fillText(`Allowed Range: 45.0° - 135.0°`, 20, 50);

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
