<!DOCTYPE html>
<html>
<head>
  <title>Verlet Spider - Animated</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #222; }
    canvas { display: block; cursor: none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script type="module">
    import { VerletJS, Particle, DistanceConstraint, AngleConstraint, Composite, Vec2, rotateComposite } from '../../dist/verlet-engine.es.js';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const sim = new VerletJS(canvas.width, canvas.height);
    sim.gravity = new Vec2(0, 0);
    sim.friction = 0.98;

    // (The createSpider function is exactly the same as before)
    function createSpider(origin) {
      const composite = new Composite();
      const legStiffness = 0.99;
      const bodyStiffness = 1;
      const angleStiffness = 0.9;

      composite.thorax = new Particle(origin);
      composite.head = new Particle(origin.add(new Vec2(0, -5)));
      composite.abdomen = new Particle(origin.add(new Vec2(0, 10)));
      composite.particles.push(composite.thorax, composite.head, composite.abdomen);
      composite.constraints.push(new DistanceConstraint(composite.head, composite.thorax, bodyStiffness));
      composite.constraints.push(new DistanceConstraint(composite.abdomen, composite.thorax, bodyStiffness));
      composite.constraints.push(new AngleConstraint(composite.abdomen, composite.thorax, composite.head, 0.1));

      composite.feet = [];

      for (let i = 0; i < 4; ++i) {
        const lenCoef = (i === 1 || i === 2) ? 0.8 : 1;
        const leg1_l = new Particle(composite.thorax.pos.add(new Vec2(-3, (i - 1.5) * 3)));
        const leg1_r = new Particle(composite.thorax.pos.add(new Vec2(3, (i - 1.5) * 3)));
        const leg2_l = new Particle(leg1_l.pos.add(new Vec2(-20, (i - 1.5) * 30).normal().scale(20 * lenCoef)));
        const leg2_r = new Particle(leg1_r.pos.add(new Vec2(20, (i - 1.5) * 30).normal().scale(20 * lenCoef)));
        const leg3_l = new Particle(leg2_l.pos.add(new Vec2(-20, (i - 1.5) * 50).normal().scale(20 * lenCoef)));
        const leg3_r = new Particle(leg2_r.pos.add(new Vec2(20, (i - 1.5) * 50).normal().scale(20 * lenCoef)));
        const foot_l = new Particle(leg3_l.pos.add(new Vec2(-20, (i - 1.5) * 100).normal().scale(12 * lenCoef)));
        const foot_r = new Particle(leg3_r.pos.add(new Vec2(20, (i - 1.5) * 100).normal().scale(12 * lenCoef)));
        composite.particles.push(leg1_l, leg1_r, leg2_l, leg2_r, leg3_l, leg3_r, foot_l, foot_r);
        composite.feet.push(foot_l, foot_r);

        composite.constraints.push(new DistanceConstraint(leg1_l, composite.thorax, legStiffness));
        composite.constraints.push(new DistanceConstraint(leg1_r, composite.thorax, legStiffness));
        composite.constraints.push(new DistanceConstraint(leg2_l, leg1_l, legStiffness));
        composite.constraints.push(new DistanceConstraint(leg2_r, leg1_r, legStiffness));
        composite.constraints.push(new DistanceConstraint(leg3_l, leg2_l, legStiffness));
        composite.constraints.push(new DistanceConstraint(leg3_r, leg2_r, legStiffness));
        composite.constraints.push(new DistanceConstraint(foot_l, leg3_l, legStiffness));
        composite.constraints.push(new DistanceConstraint(foot_r, leg3_r, legStiffness));
        composite.constraints.push(new AngleConstraint(composite.thorax, leg1_l, leg2_l, angleStiffness));
        composite.constraints.push(new AngleConstraint(composite.thorax, leg1_r, leg2_r, angleStiffness));
        composite.constraints.push(new AngleConstraint(leg1_l, leg2_l, leg3_l, angleStiffness));
        composite.constraints.push(new AngleConstraint(leg1_r, leg2_r, leg3_r, angleStiffness));
        composite.constraints.push(new AngleConstraint(leg2_l, leg3_l, foot_l, angleStiffness));
        composite.constraints.push(new AngleConstraint(leg2_r, leg3_r, foot_r, angleStiffness));
      }
      return composite;
    }

    const spiderComposite = createSpider(new Vec2(canvas.width / 2, canvas.height / 2));
    sim.composites.push(spiderComposite);

    // --- Animation & Movement ---
    const spiderTarget = new Vec2().mutableSet(spiderComposite.head.pos);
    const mousePos = new Vec2(canvas.width / 2, canvas.height / 2);
    let stepCounter = 0;
    const stepDuration = 25; // frames for one step cycle

    // Define the resting positions of the feet relative to the body's center (thorax)
    const feetRestingOffsets = spiderComposite.feet.map(f => f.pos.sub(spiderComposite.thorax.pos));

    canvas.addEventListener('mousemove', (e) => {
      mousePos.x = e.clientX;
      mousePos.y = e.clientY;
    });

    canvas.addEventListener('mousedown', (e) => {
      spiderTarget.x = e.clientX;
      spiderTarget.y = e.clientY;
    });

    function animate() {
      const spiderBody = spiderComposite.thorax;
      const spiderHead = spiderComposite.head;
      const spiderAbdomen = spiderComposite.abdomen;

      // --- Rotation Logic ---
      const bodyAxis = spiderHead.pos.sub(spiderAbdomen.pos);
      const targetDirection = spiderTarget.sub(spiderBody.pos);
      const distanceToTarget = targetDirection.length();

      const currentAngle = Math.atan2(bodyAxis.y, bodyAxis.x);
      const targetAngle = Math.atan2(targetDirection.y, targetDirection.x);

      let angleDifference = targetAngle - currentAngle;
      while (angleDifference > Math.PI) angleDifference -= 2 * Math.PI;
      while (angleDifference < -Math.PI) angleDifference += 2 * Math.PI;

      if (Math.abs(angleDifference) > 0.05) {
        const maxRotationSpeed = 0.05;
        const rotationThisFrame = Math.max(-maxRotationSpeed, Math.min(maxRotationSpeed, angleDifference));
        rotateComposite(spiderComposite, spiderBody.pos, rotationThisFrame);
      }

      // --- Walking Logic ---
      if (Math.abs(angleDifference) < 0.5 && distanceToTarget > 20) {
        const stepPhase = Math.floor((stepCounter / stepDuration)) % 2;
        const maxSpeed = 0.8;
        const moveDirection = targetDirection.normal();

        // Move the body forward
        spiderBody.pos.mutableAdd(moveDirection.scale(maxSpeed));

        // Animate the feet
        spiderComposite.feet.forEach((foot, i) => {
          const isSteppingGroup = (i % 4) < 2; // Simple grouping: 0,1, 4,5 vs 2,3, 6,7
          
          if ((stepPhase === 0 && isSteppingGroup) || (stepPhase === 1 && !isSteppingGroup)) {
            // This foot should be stepping
            const restingOffset = feetRestingOffsets[i].rotate(new Vec2(0,0), currentAngle);
            const stepTarget = spiderBody.pos.add(restingOffset).add(moveDirection.scale(20)); // Step forward
            
            const toTarget = stepTarget.sub(foot.pos);
            const delta = toTarget.scale(0.2);
            foot.pos.mutableAdd(delta);
            foot.lastPos.mutableAdd(delta); // Apply same delta to lastPos to maintain velocity
          }
        });

        stepCounter++;
      } else {
        stepCounter = 0; // Reset step cycle when not walking
      }
      
      // --- Physics and Drawing ---
      sim.frame(16);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw spider
      ctx.strokeStyle = '#eee';
      ctx.lineWidth = 1.5;
      for (const c of sim.composites) {
        for (const constraint of c.constraints) {
          if (constraint instanceof DistanceConstraint) {
            ctx.beginPath();
            ctx.moveTo(constraint.a.pos.x, constraint.a.pos.y);
            ctx.lineTo(constraint.b.pos.x, constraint.b.pos.y);
            ctx.stroke();
          }
        }
        ctx.fillStyle = '#eee';
        ctx.beginPath(); ctx.arc(c.head.pos.x, c.head.pos.y, 4, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(c.thorax.pos.x, c.thorax.pos.y, 4, 0, 2 * Math.PI); ctx.fill();
        ctx.beginPath(); ctx.arc(c.abdomen.pos.x, c.abdomen.pos.y, 8, 0, 2 * Math.PI); ctx.fill();
      }

      // Draw mouse position indicator
      ctx.beginPath();
      ctx.arc(mousePos.x, mousePos.y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.fill();

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
