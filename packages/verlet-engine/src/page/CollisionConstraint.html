<!DOCTYPE html>
<html lang="en">

<head>
  <title>Test: Collision Constraint</title>
  <meta charset="UTF-8" />
  <style>
    body {
      font-family: sans-serif;
      background: #222;
      color: #eee;
      text-align: center;
    }

    canvas {
      background: #fff;
    }

    nav {
      margin: 10px;
    }

    nav a {
      color: #0af;
      text-decoration: none;
    }
  </style>
</head>

<body>
  <nav>
    <a href="../../index.html">Home</a> |
    <a href="lineSegment.html">Line Segment</a> |
    <a href="tire.html">Tires</a> |
    <a href="square.html">Square</a> |
    <a href="spirale.html">Spirale</a> |
    <a href="CollisionConstraint.html">Collision Constraint</a>
  </nav>
  <h1>Test: Collision Constraint</h1>
  <p>Cette démonstration montre la `CollisionConstraint` en action.<br/>
     Chaque pneu est un composite de particules. Une `CollisionConstraint` est ajoutée entre chaque particule de chaque pneu.<br/>
     Cela empêche les pneus de passer à travers les autres.</p>
  <canvas id="scratch" style="width: 800px; height: 500px;"></canvas>

  <script type="module">
    import { VerletJS, Vec2, tire, CollisionConstraint, Composite } from '../../dist/verlet-engine.es.js';

    window.onload = function () {
      const canvas = document.getElementById("scratch");
      const ctx = canvas.getContext("2d");
      const width = parseInt(canvas.style.width);
      const height = parseInt(canvas.style.height);
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);

      const sim = new VerletJS(width, height, { gravity: new Vec2(0, 0.2), friction: 0.99, groundFriction: 0.8, solverIterations: 15, restitution: 0.8 });

      // create three tires
      const tire1 = tire(sim, new Vec2(200, 50), 50, 7, 0.1, 0.2);
      const tire2 = tire(sim, new Vec2(400, 50), 50, 7, 0.1, 0.2);
      const tire3 = tire(sim, new Vec2(600, 50), 50, 7, 0.1, 0.2);
      
      // give them initial velocity
      tire1.particles.forEach(p => { p.lastPos.x -= 4; });
      tire3.particles.forEach(p => { p.lastPos.x += 4; });

      // Style the tires
      tire1.particles.forEach(p => { p.style = { color: '#2dad8f', radius: 3 }; });
      tire1.constraints.forEach(c => { c.style = { color: '#2dad8f', lineWidth: 1 }; });
      tire2.particles.forEach(p => { p.style = { color: '#800080', radius: 3 }; });
      tire2.constraints.forEach(c => { c.style = { color: '#800080', lineWidth: 1 }; });
      tire3.particles.forEach(p => { p.style = { color: '#ffa500', radius: 3 }; });
      tire3.constraints.forEach(c => { c.style = { color: '#ffa500', lineWidth: 1 }; });

      // create a composite for collision constraints
      const collisionComposite = new Composite();
      const tires = [tire1, tire2, tire3];

      // add collision constraints between particles of different tires
      for (let i = 0; i < tires.length; i++) {
        for (let j = i + 1; j < tires.length; j++) {
          const particles1 = tires[i].particles;
          const particles2 = tires[j].particles;
          for (const p1 of particles1) {
            for (const p2 of particles2) {
              collisionComposite.constraints.push(new CollisionConstraint(p1, p2, 0.8));
            }
          }
        }
      }

      sim.composites.push(collisionComposite);

      let draggedEntity = null;
      const mouse = new Vec2(0, 0);
      const selectionRadius = 20;
      const highlightColor = "#4f545c";

      function nearestEntity() {
        let d2Nearest = Infinity;
        let entity = null;
        for (const c of sim.composites) {
          for (const p of c.particles) {
            const d2 = p.pos.dist2(mouse);
            if (d2 < d2Nearest && d2 < selectionRadius * selectionRadius) {
              entity = p;
              d2Nearest = d2;
            }
          }
        }
        return entity;
      }

      canvas.onmousedown = function (e) { draggedEntity = nearestEntity(); };
      canvas.onmouseup = function (e) { draggedEntity = null; };
      canvas.onmousemove = function (e) {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
        if (draggedEntity) draggedEntity.pos.mutableSet(mouse);
      };

      function draw() {
        ctx.clearRect(0, 0, width, height);
        for (const c of sim.composites) {
          for (const constraint of c.constraints) {
            if (typeof (constraint).draw === 'function') (constraint).draw(ctx);
          }
          for (const p of c.particles) {
            ctx.beginPath();
            ctx.arc(p.pos.x, p.pos.y, p.style?.radius || 2, 0, 2 * Math.PI);
            ctx.fillStyle = p.style?.color || "#2dad8f";
            ctx.fill();
          }
        }
        const nearest = draggedEntity || nearestEntity();
        if (nearest) {
          ctx.beginPath();
          ctx.arc(nearest.pos.x, nearest.pos.y, 8, 0, 2 * Math.PI);
          ctx.strokeStyle = highlightColor;
          ctx.stroke();
        }
      }

      let lastTimestamp = 0;
      function loop(currentTimestamp) {
        const deltaTime = (currentTimestamp - lastTimestamp) / 1000; // Convert to seconds
        lastTimestamp = currentTimestamp;

        sim.frame(deltaTime);
        draw();
        requestAnimationFrame(loop);
      };

      loop();
    };
  </script>
</body>

</html>